/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/Chart.js":
/*!*************************!*\
  !*** ./src/js/Chart.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Chart; });\n/* harmony import */ var _ChartController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChartController */ \"./src/js/ChartController.js\");\n\r\n\r\nclass Chart {\r\n\r\n\tconstructor(data){\r\n\t\tthis.chart = new _ChartController__WEBPACK_IMPORTED_MODULE_0__[\"default\"](data);\r\n\t}\r\n\r\n\tchangeSetting(settingName, settingValue){\r\n\t\tthis.chart.data.settings[settingName] = settingValue;\r\n\t\tthis.chart.updateSettings();\r\n\t}\r\n}\n\n//# sourceURL=webpack:///./src/js/Chart.js?");

/***/ }),

/***/ "./src/js/ChartController.js":
/*!***********************************!*\
  !*** ./src/js/ChartController.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ChartController; });\n/* harmony import */ var _ChartData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChartData */ \"./src/js/ChartData.js\");\n/* harmony import */ var _ChartTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ChartTemplate */ \"./src/js/ChartTemplate.js\");\n\r\n\r\n\r\nclass ChartController{\r\n\r\n\tconstructor(data){\r\n\r\n\t\tthis.data = new _ChartData__WEBPACK_IMPORTED_MODULE_0__[\"default\"](data);\r\n\r\n\t\tthis.view = new _ChartTemplate__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\r\n\t\t\tappendTarget: 'body',\r\n\t\t\tsettings: this.data.settings\r\n\t\t});\r\n\r\n\t\tthis.displayedDates = [];\r\n\r\n\t\tthis.displayedValues = [];\r\n\r\n\t\tthis.controlsState = {\r\n\t\t\tstartClicked        : false,\r\n\t\t\tendClicked          : false,\r\n\t\t\tmapRangeClicked     : false,\r\n\t\t\tchartMove           : false,\r\n\t\t\tchartReverceMove    : false,\r\n\t\t\tstartPosition       : 0,\r\n\t\t\tendPosition         : this.viewBoxWidth,\r\n\t\t\tclickInitialPosition: 0,\r\n\t\t\tminMapViewRange     : this.data.settings.minMapSpace\r\n\t\t};\r\n\r\n\t\tthis.main();\r\n\t}\r\n\r\n\tget viewBoxWidth(){\r\n\t\treturn this.data.settings.viewBoxWidth;\r\n\t}\r\n\tget chartSizeCoeff(){\r\n\t\treturn this.viewBoxWidth / this.view.elements.chartWrapper.clientWidth;\r\n\t}\r\n\r\n\tget currentStart(){\r\n\t\treturn this.view.startChartValue;\r\n\t}\r\n\r\n\tget currentEnd(){\r\n\t\treturn this.view.endChartValue + this.view.endChartWidth;\r\n\t}\r\n\r\n\tget absoluteMinMax(){\r\n\r\n\t\tconst start = this.data.totalValues.slice().shift();\r\n\t\tconst end = this.data.totalValues.slice().pop();\r\n\t\tconst range = end - start;\r\n\r\n\t\tlet min = start - range * 0.05;\r\n\r\n\t\tlet max = Math.round(end + range * 0.05);\r\n\r\n\t\tmin = Math.round(min / this.getOOM(min)) * this.getOOM(min);\r\n\r\n\t\tif ((min > 0 && ((min + range * 0.05) < 0)) || (min < 0 && ((min - range * 0.05) < 0))){\r\n\t\t\tmin = 0;\r\n\t\t}\r\n\r\n\t\treturn {min, max}\r\n\t}\r\n\r\n\tget stepOfValues(){\r\n\r\n\t\tconst chartValuesMinMax = this.getChartMinMaxValueInRange(this.getStartAbsoluteValue(this.currentStart), this.getEndAbsoluteValue(this.currentEnd));\r\n\r\n\t\tconst countValuesToDisplay = Math.floor(this.view.elements.chart.clientHeight / 60);\r\n\r\n\t\tlet range = chartValuesMinMax.max - this.absoluteMinMax.min;\r\n\r\n\t\tlet stepNotRounded = range / countValuesToDisplay;\r\n\r\n\t\tlet step = Math.ceil(stepNotRounded / this.getOOM(stepNotRounded)) * this.getOOM(stepNotRounded);\r\n\r\n\t\tconst min = step - this.absoluteMinMax.min > chartValuesMinMax.min ? this.absoluteMinMax.min : chartValuesMinMax.min;\r\n\r\n\t\tif (min !== this.absoluteMinMax.min){\r\n\r\n\t\t\trange = chartValuesMinMax.max - chartValuesMinMax.min;\r\n\r\n\t\t\tstepNotRounded = range / countValuesToDisplay;\r\n\r\n\t\t\tstep = Math.ceil(stepNotRounded / this.getOOM(stepNotRounded)) * this.getOOM(stepNotRounded);\r\n\t\t}\r\n\r\n\t\treturn {min, step};\r\n\r\n\t}\r\n\r\n\tgetChartMinMaxValueInRange(start, end){\r\n\r\n\t\tlet min = 99999999999999999;\r\n\t\tlet max = 0;\r\n\r\n\t\tif (this.data.activeLinesCount === 0){\r\n\t\t\t// Prevent the not smooth animation on disable last chart\r\n\t\t\treturn this.absoluteMinMax;\r\n\t\t}\r\n\r\n\t\tfor (let coordIndex in this.data.x){\r\n\t\t\tif (this.data.x[coordIndex] >= start && this.data.x[coordIndex] <= end){\r\n\t\t\t\tfor (let lineIndex in this.data.lines){\r\n\t\t\t\t\tconst line = this.data.lines[lineIndex];\r\n\t\t\t\t\tif (line.active){\r\n\t\t\t\t\t\tmin = line.coords[coordIndex] < min ? line.coords[coordIndex] : min;\r\n\t\t\t\t\t\tmax = line.coords[coordIndex] > max ? line.coords[coordIndex] : max;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tfor (let lineIndex in this.data.lines){\r\n\t\t\t\t\tconst line = this.data.lines[lineIndex];\r\n\t\t\t\t\tif (line.active){\r\n\t\t\t\t\t\tmin = line.coords[coordIndex] < min ? line.coords[coordIndex] : min;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst range = max - min;\r\n\r\n\t\tmax += Math.round(range * 0.05);\r\n\r\n\t\tif (min > 0 && (min - range * 0.05) < 0){\r\n\t\t\tmin = 0;\r\n\t\t}\r\n\r\n\t\tmin = Math.round(min / (this.getOOM(min))) * this.getOOM(min);\r\n\r\n\t\treturn {min, max};\r\n\t}\r\n\r\n\tgetCoordsByIndex(coordIndex){\r\n\t\tconst x = this.data.x[coordIndex];\r\n\r\n\t\tconst coords = {\r\n\t\t\tx: x,\r\n\t\t\tvalues: []\r\n\t\t};\r\n\r\n\t\tfor (const lineId in this.data.lines){\r\n\t\t\tif (this.data.lines[lineId].active){\r\n\t\t\t\tcoords.values.push({\r\n\t\t\t\t\ty: this.data.lines[lineId].coords[coordIndex],\r\n\t\t\t\t\tcolor: this.data.lines[lineId].color,\r\n\t\t\t\t\tname: this.data.lines[lineId].name\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (coords.values.length > 0){\r\n\t\t\treturn coords;\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetCoordIndexByClientX(clientX){\r\n\r\n\t\tconst chart = this.view.elements.chart;\r\n\r\n\t\tconst chartCoeff = chart.querySelector('.chart-wrapper').getBoundingClientRect().width / chart.clientWidth;\r\n\r\n\t\t// get window start position inside the full chart\r\n\t\tconst chartStart = this.viewBoxWidth * (chartCoeff * this.controlsState.startPosition / this.viewBoxWidth);\r\n\r\n\t\tconst chartFullWidth = this.viewBoxWidth * chartCoeff;\r\n\r\n\t\tconst chartIntervalWidth = chartFullWidth / this.data.x.length;\r\n\r\n\t\t// get cursor position inside the full chart\r\n\t\tconst cursorPositionInChart = chartStart + (clientX - chart.getBoundingClientRect().left) / chart.clientWidth * this.viewBoxWidth;\r\n\r\n\t\tconst cursorShift = (((chartFullWidth / 2) - cursorPositionInChart) / chartFullWidth) * chartIntervalWidth;\r\n\r\n\t\tconst percentCursorPositionInChart = cursorPositionInChart / this.viewBoxWidth / chartCoeff;\r\n\r\n\t\treturn Math.floor(this.data.x.length * percentCursorPositionInChart + (cursorShift / chartCoeff));\r\n\r\n\t}\r\n\r\n\tgetStartAbsoluteValue(startPercent){\r\n\r\n\t\treturn this.data.totalStart + ((this.data.totalEnd - this.data.totalStart) * (startPercent / this.viewBoxWidth));\r\n\r\n\t}\r\n\r\n\tgetEndAbsoluteValue(endPercent){\r\n\r\n\t\treturn this.data.totalEnd - ((this.data.totalEnd - this.data.totalStart) * (1 - (endPercent / this.viewBoxWidth)));\r\n\r\n\t}\r\n\r\n\t// get order of magnitude\r\n\tgetOOM(n) {\r\n\t\tif (Math.abs(n) > 0){\r\n\t\t\tconst order = Math.floor(Math.log(Math.abs(n)) / Math.LN10 + 0.000000001);\r\n\t\t\treturn Math.pow(10,order);\r\n\t\t}else{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tmain(){\r\n\r\n\t\tthis.view.init();\r\n\r\n\t\tthis.updateLines({target: this.view.elements.chart, drawValues: true});\r\n\t\tthis.updateLines({target: this.view.elements.map});\r\n\r\n\t\tthis.view.initControlButtons(this.data.lines);\r\n\r\n\t\tthis.setEventListeners();\r\n\r\n\t}\r\n\r\n\r\n\tsetEventListeners(){\r\n\r\n\t\tthis.buttonsListeners();\r\n\r\n\t\tthis.dragStartListeners();\r\n\r\n\t\tthis.dragEndListeners();\r\n\r\n\t\tthis.moveListeners();\r\n\r\n\r\n\r\n\t}\r\n\r\n\tupdateLines({target, startPercent = 0, endPercent = this.data.settings.viewBoxWidth, drawValues = false}){\r\n\r\n\t\tlet start = this.getStartAbsoluteValue(startPercent);\r\n\t\tlet end = this.getEndAbsoluteValue(endPercent);\r\n\r\n\t\t// Disable zoom less than 100%\r\n\t\tstart = this.totalStart > start ? this.totalStart : start;\r\n\t\tend = this.totalEnd < end ? this.totalEnd : end;\r\n\r\n\t\tconst chartValuesMinMax = this.getChartMinMaxValueInRange(start, end);\r\n\r\n\t\tthis.view.createLines({\r\n\t\t\ttarget,\r\n\t\t\tx: this.data.x,\r\n\t\t\tlines: this.data.lines,\r\n\t\t\tstart,\r\n\t\t\tend,\r\n\t\t\tmin: this.stepOfValues.min,\r\n\t\t\tmax: chartValuesMinMax.max\r\n\t\t});\r\n\r\n\t\tif (drawValues){\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\tthis.updateDates(target, start, end);\r\n\t\t\t\tthis.updateValues(target, chartValuesMinMax);\r\n\t\t\t}, 0);\r\n\t\t}\r\n\t\tif (this.data.activeLinesCount > 0){\r\n\t\t\tthis.updateChartData(true);\r\n\t\t}else{\r\n\t\t\tthis.updateChartData(false);\r\n\t\t}\r\n\t}\r\n\r\n\tupdateValues(target, chartValuesMinMax){\r\n\r\n\t\tif (this.data.activeLinesCount > 0){\r\n\r\n\t\t\tconst step = this.stepOfValues.step;\r\n\r\n\t\t\tconst min = this.stepOfValues.min;\r\n\r\n\t\t\tconst totalRange = this.absoluteMinMax.max - min;\r\n\r\n\t\t\tconst totalDrawsCount = Math.floor(totalRange / step);\r\n\r\n\t\t\tconst steps = [];\r\n\r\n\t\t\tconst currentStepsClasses = [];\r\n\r\n\t\t\tfor (let i = 0; i <= totalDrawsCount; i++){\r\n\t\t\t\tconst value = (step * i) + min;\r\n\t\t\t\tsteps.push(value);\r\n\t\t\t\tcurrentStepsClasses.push(`value-${value}`);\r\n\t\t\t}\r\n\r\n\t\t\tthis.view.removeItems('value-item', currentStepsClasses, 'hideByY', {min: min, max: chartValuesMinMax.max});\r\n\r\n\t\t\tthis.view.createValues({\r\n\t\t\t\ttarget,\r\n\t\t\t\tsteps,\r\n\t\t\t\tmin: min,\r\n\t\t\t\tmax: chartValuesMinMax.max\r\n\t\t\t});\r\n\t\t}else{\r\n\t\t\tthis.view.removeItems('value-item', [], 'hide');\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateDates(target, start, end){\r\n\r\n\t\tif (this.data.activeLinesCount > 0){\r\n\r\n\t\t\tconst range = this.data.x.slice();\r\n\r\n\t\t\tlet totalStartDate = range.shift();\r\n\r\n\t\t\tlet totalEndDate = range.pop();\r\n\r\n\t\t\tconst offset = Math.floor((totalEndDate - totalStartDate) * (this.chartSizeCoeff / 4));\r\n\r\n\t\t\ttotalStartDate += offset;\r\n\r\n\t\t\ttotalEndDate -= offset;\r\n\r\n\t\t\tconst windowWidthDrawsCount = Math.floor((target.getBoundingClientRect().width) / 80);\r\n\r\n\t\t\tlet myltiple = Math.floor((target.querySelector('.chart-wrapper').getBoundingClientRect().width / target.getBoundingClientRect().width) * 1.1);\r\n\r\n\t\t\tmyltiple = Math.pow(2, Math.floor(Math.log2(myltiple)));\r\n\r\n\t\t\tconst totalDrawsCount = windowWidthDrawsCount * myltiple;\r\n\r\n\t\t\tlet step = Math.floor((totalEndDate - totalStartDate) / totalDrawsCount);\r\n\r\n\t\t\tif (!this.controlsState.mapRangeClicked){\r\n\r\n\t\t\t\tthis.displayedDates = [];\r\n\r\n\t\t\t\tconst currentDatesClasses = [];\r\n\r\n\t\t\t\tfor (let i = 0; i <= totalDrawsCount; i++){\r\n\t\t\t\t\tconst dateValue = Math.floor((Number(totalStartDate) + (step * i)) / 86400000) * 86400000;\r\n\t\t\t\t\tcurrentDatesClasses.push(`date-${dateValue}`);\r\n\t\t\t\t\tthis.displayedDates.push(dateValue);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (offset > step){\r\n\t\t\t\t\tcurrentDatesClasses.push(`date-${totalStartDate - offset}`);\r\n\t\t\t\t\tthis.displayedDates.push(totalStartDate - offset);\r\n\t\t\t\t\tcurrentDatesClasses.push(`date-${totalEndDate + offset}`);\r\n\t\t\t\t\tthis.displayedDates.push(totalEndDate + offset);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.view.removeItems('date-text', currentDatesClasses, 'hide');\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.view.createDates({\r\n\t\t\t\ttarget,\r\n\t\t\t\tdates: this.displayedDates,\r\n\t\t\t\tstart,\r\n\t\t\t\tend,\r\n\t\t\t\ttotalStartDate: this.data.totalStart,\r\n\t\t\t\ttotalEndDate: this.data.totalEnd\r\n\t\t\t});\r\n\t\t}else{\r\n\t\t\tthis.view.removeItems('date-text', [], 'hide');\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateTooltip(event){\r\n\r\n\t\tlet start = this.getStartAbsoluteValue(this.currentStart);\r\n\r\n\t\tlet end = this.getEndAbsoluteValue(this.currentEnd);\r\n\r\n\t\tconst chartValuesMinMax = this.getChartMinMaxValueInRange(start, end);\r\n\r\n\t\tconst coordIndex = this.getCoordIndexByClientX(event.clientX || event.touches[0].clientX);\r\n\r\n\t\tconst coords = this.getCoordsByIndex(coordIndex);\r\n\r\n\t\tif(coords.x){\r\n\t\t\tthis.view.createTooltip({\r\n\t\t\t\tx: coords.x,\r\n\t\t\t\tvalues: coords.values,\r\n\t\t\t\tclientY: event.clientY || event.touches[0].clientY,\r\n\t\t\t\tstart,\r\n\t\t\t\tend,\r\n\t\t\t\tmin: this.stepOfValues.min,\r\n\t\t\t\tmax: chartValuesMinMax.max\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tupdateChartData(hasDataToDisplay){\r\n\t\tif (hasDataToDisplay){\r\n\t\t\tthis.view.removeItems('no-data-placeholder');\r\n\t\t}else{\r\n\t\t\tthis.view.removeItems('tooltip-item');\r\n\t\t\tthis.view.addNoDataPlaceholder();\r\n\t\t}\r\n\t}\r\n\r\n\tupdateSettings(){\r\n\t\tthis.view.settings = this.data.settings;\r\n\t\tthis.view.setCurrentColorScheme();\r\n\t}\r\n\r\n\tmoveChart(event){\r\n\r\n\t\tconst clientX = event.clientX || event.touches[0].clientX;\r\n\r\n\t\tif (this.controlsState.startClicked || this.controlsState.mapRangeClicked){\r\n\r\n\t\t\tconst valueStart = this.controlsState.startPosition + (0 - (this.controlsState.clickInitialPosition - clientX) / this.view.elements.layout.clientWidth) * this.viewBoxWidth;\r\n\r\n\t\t\tthis.view.changeStartPosition(valueStart, this.controlsState.minMapViewRange);\r\n\r\n\t\t}\r\n\r\n\t\tif (this.controlsState.endClicked || this.controlsState.mapRangeClicked){\r\n\r\n\t\t\tconst valueEnd = (this.controlsState.endPosition + (0 - (this.controlsState.clickInitialPosition - clientX) / this.view.elements.layout.clientWidth) * this.viewBoxWidth);\r\n\r\n\t\t\tthis.view.changeEndPosition(valueEnd, this.controlsState.minMapViewRange);\r\n\t\t}\r\n\r\n\r\n\t\tif(this.controlsState.chartMove){\r\n\r\n\t\t\tthis.view.removeItems('tooltip-item');\r\n\r\n\t\t\tconst startPercent = this.currentStart;\r\n\r\n\t\t\tconst endPercent = this.currentEnd;\r\n\r\n\t\t\tthis.view.elements.chart.classList.add('dragging');\r\n\r\n\t\t\tthis.updateLines({target: this.view.elements.chart, startPercent, endPercent, drawValues: true});\r\n\r\n\t\t\tsetTimeout(() => {\r\n\r\n\t\t\t\tthis.view.elements.chart.classList.remove('dragging');\r\n\r\n\t\t\t}, 0);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tbuttonsListeners(){\r\n\r\n\t\tfor (const button of this.view.elements.buttons){\r\n\r\n\t\t\tbutton.addEventListener('click', () => {\r\n\r\n\t\t\t\tconst lineID = button.dataset.lineid;\r\n\r\n\t\t\t\tconst lines = this.view.elements.layout.getElementsByClassName(`line-${lineID}`);\r\n\r\n\t\t\t\tif (this.data.lines[lineID].active){\r\n\t\t\t\t\tbutton.classList.remove('active');\r\n\t\t\t\t\tthis.data.lines[lineID].active = false;\r\n\t\t\t\t\tfor (const line of lines){\r\n\t\t\t\t\t\tline.style.opacity = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tbutton.classList.add('active');\r\n\t\t\t\t\tthis.data.lines[lineID].active = true;\r\n\t\t\t\t\tfor (const line of lines){\r\n\t\t\t\t\t\tline.style.opacity = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.updateLines({\r\n\t\t\t\t\ttarget: this.view.elements.chart,\r\n\t\t\t\t\tstartPercent: this.currentStart,\r\n\t\t\t\t\tendPercent: this.currentEnd,\r\n\t\t\t\t\tdrawValues: true\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis.updateLines({\r\n\t\t\t\t\ttarget: this.view.elements.map,\r\n\t\t\t\t\tstartPercent: 0,\r\n\t\t\t\t\tendPercent: this.viewBoxWidth,\r\n\t\t\t\t\tdrawValues: false\r\n\t\t\t\t});\r\n\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tdragEndListeners(){\r\n\r\n\t\tdocument.addEventListener('mouseup',  () => this.clearConsrolState());\r\n\t\tdocument.addEventListener('touchend', () => this.clearConsrolState());\r\n\r\n\t}\r\n\r\n\tdragStartListeners(){\r\n\r\n\t\t// move chart by dragging map range\r\n\t\tthis.view.layoutContorls.viewRange.addEventListener('mousedown', event => {\r\n\t\t\tthis.controlsState.clickInitialPosition = event.clientX;\r\n\t\t\tthis.controlsState.mapRangeClicked      = true;\r\n\t\t\tthis.controlsState.chartMove            = true;\r\n\t\t\tthis.controlsState.minMapViewRange      = this.currentEnd - this.currentStart;\r\n\t\t});\r\n\r\n\t\tthis.view.layoutContorls.viewRange.addEventListener('touchstart', event => {\r\n\t\t\tthis.controlsState.clickInitialPosition = event.touches[0].clientX;\r\n\t\t\tthis.controlsState.mapRangeClicked      = true;\r\n\t\t\tthis.controlsState.chartMove            = true;\r\n\t\t\tthis.controlsState.minMapViewRange      = this.currentEnd - this.currentStart;\r\n\t\t});\r\n\r\n\r\n\r\n\t\t// change start position\r\n\t\tthis.view.layoutContorls.startChartSlider.addEventListener('mousedown', event => {\r\n\t\t\tthis.controlsState.clickInitialPosition = event.clientX;\r\n\t\t\tthis.controlsState.chartMove            = true;\r\n\t\t\tthis.controlsState.startClicked         = true;\r\n\t\t});\r\n\r\n\t\tthis.view.layoutContorls.startChartSlider.addEventListener('touchstart', event => {\r\n\t\t\tthis.controlsState.clickInitialPosition = event.touches[0].clientX;\r\n\t\t\tthis.controlsState.chartMove            = true;\r\n\t\t\tthis.controlsState.startClicked         = true;\r\n\t\t});\r\n\r\n\r\n\t\t// change end position\r\n\t\tthis.view.layoutContorls.endChartSlider.addEventListener('mousedown', event => {\r\n\t\t\tthis.controlsState.clickInitialPosition = event.clientX;\r\n\t\t\tthis.controlsState.chartMove            = true;\r\n\t\t\tthis.controlsState.endClicked           = true;\r\n\t\t});\r\n\r\n\t\tthis.view.layoutContorls.endChartSlider.addEventListener('touchstart', event => {\r\n\t\t\tthis.controlsState.clickInitialPosition = event.touches[0].clientX;\r\n\t\t\tthis.controlsState.chartMove            = true;\r\n\t\t\tthis.controlsState.endClicked           = true;\r\n\t\t});\r\n\r\n\r\n\r\n\t}\r\n\r\n\tmoveListeners(){\r\n\r\n\t\tdocument.addEventListener('mousemove', (event) => {\r\n\t\t\tthis.moveChart(event);\r\n\t\t});\r\n\r\n\t\tdocument.addEventListener('touchmove', (event) => {\r\n\t\t\tthis.moveChart(event);\r\n\t\t});\r\n\r\n\t\tthis.view.elements.chart.addEventListener('mousemove', event => this.updateTooltip(event));\r\n\t\tthis.view.elements.chart.addEventListener('touchmove', event => this.updateTooltip(event));\r\n\r\n\t\tthis.view.elements.chart.addEventListener('mouseleave', () => this.view.removeItems('tooltip-item'));\r\n\r\n\t}\r\n\r\n\r\n\tclearConsrolState(){\r\n\t\tthis.controlsState.startPosition    = this.view.startChartValue;\r\n\t\tthis.controlsState.endPosition      = this.view.endChartValue;\r\n\t\tthis.controlsState.minMapViewRange  = this.data.settings.minMapSpace;\r\n\t\tthis.controlsState.startClicked     = false;\r\n\t\tthis.controlsState.endClicked       = false;\r\n\t\tthis.controlsState.chartReverceMove = false;\r\n\t\tthis.controlsState.chartMove        = false;\r\n\t\tthis.controlsState.mapRangeClicked  = false;\r\n\t}\r\n\r\n\r\n\r\n\r\n}\n\n//# sourceURL=webpack:///./src/js/ChartController.js?");

/***/ }),

/***/ "./src/js/ChartData.js":
/*!*****************************!*\
  !*** ./src/js/ChartData.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ChartData; });\nclass ChartData {\r\n\r\n\tconstructor(data){\r\n\r\n\t\tthis.settings = {\r\n\r\n\t\t\t// width of viewBox\r\n\t\t\tviewBoxWidth: 100,\r\n\r\n\t\t\tnightMode: {\r\n\r\n\t\t\t\t// background of all chart\r\n\t\t\t\tbackground: '#242f3e',\r\n\r\n\t\t\t\t// background of tooltip\r\n\t\t\t\ttooltipBackground: '#253241',\r\n\r\n\t\t\t\t// color of tooltip\r\n\t\t\t\ttooltipColor: '#ffffff',\r\n\r\n\t\t\t\t// line of selected date color\r\n\t\t\t\ttooltipLineColor: '#3b4a5a',\r\n\r\n\t\t\t\t// color of value lines\r\n\t\t\t\tvalueLineColor: '#293544',\r\n\r\n\t\t\t\t// dates and values on X and Y axis color\r\n\t\t\t\ttextColor: '#546778',\r\n\r\n\t\t\t\t// color of dragging blocks (start and end on map)\r\n\t\t\t\tstartEndColor: 'rgba(112, 149, 185, 0.5)',\r\n\r\n\t\t\t\t// color on map of hiden chart elements\r\n\t\t\t\tmapNotVisibleBackground: 'rgba(16, 25, 37, 0.5)',\r\n\r\n\t\t\t},\r\n\r\n\t\t\tdayMode: {\r\n\r\n\t\t\t\t// background of all chart\r\n\t\t\t\tbackground: '#ffffff',\r\n\r\n\t\t\t\t// background of tooltip\r\n\t\t\t\ttooltipBackground: '#ffffff',\r\n\r\n\t\t\t\t// color of tooltip\r\n\t\t\t\ttooltipColor: '#222222',\r\n\r\n\t\t\t\t// line of selected date color\r\n\t\t\t\ttooltipLineColor: '#dfe6eb',\r\n\r\n\t\t\t\t// color of value lines\r\n\t\t\t\tvalueLineColor: '#f2f4f5',\r\n\r\n\t\t\t\t// dates and values on X and Y axis color\r\n\t\t\t\ttextColor: '#96a2aa',\r\n\r\n\t\t\t\t// color of dragging blocks (start and end on map)\r\n\t\t\t\tstartEndColor: 'rgba(183, 207, 223, 0.5)',\r\n\r\n\t\t\t\t// color on map of hiden chart elements\r\n\t\t\t\tmapNotVisibleBackground: 'rgba(221, 234, 241, 0.5)',\r\n\r\n\t\t\t},\r\n\r\n\t\t\tmonthNames: [\r\n\t\t\t\t\"Dec\", \"Jan\", \"Feb\", \"Mar\",\r\n\t\t\t\t\"Apr\", \"May\", \"Jun\", \"Jul\",\r\n\t\t\t\t\"Aug\", \"Sep\", \"Oct\",\r\n\t\t\t\t\"Nov\"\r\n\t\t\t],\r\n\r\n\t\t\tweekdaysNames: [\r\n\t\t\t\t\"Sun\", \"Mon\",\r\n\t\t\t\t\"Tue\", \"Wed\",\r\n\t\t\t\t\"Thu\", \"Fri\",\r\n\t\t\t\t\"Sat\"\r\n\t\t\t],\r\n\r\n\t\t\t// width of sliders on map (in percents)\r\n\t\t\tmapSliderWidth: 0.03,\r\n\r\n\t\t\tdecimalsInThousandRounding: 2,\r\n\r\n\t\t\tfontSize: 13,\r\n\r\n\t\t\tcurrentMode: 'day',\r\n\r\n\t\t\tchartLineWidth: 3,\r\n\r\n\t\t\tvalueLineWidth: 1,\r\n\r\n\t\t\ttooltipCircleLineWidth: 2,\r\n\r\n\t\t\ttooltipOffsetFromCursor: 15,\r\n\r\n\t\t\ttooltipLineWidth: 2,\r\n\r\n\t\t\ttooltipCirclesRadius: 5,\r\n\r\n\t\t\t// height relative to the wrapper (in percent)\r\n\t\t\tchartHeight: 0.93,\r\n\r\n\t\t\t// minimal space between start and end\r\n\t\t\tminMapSpace: 15,\r\n\t\t}\r\n\r\n\t\tthis.lines = {};\r\n\r\n\t\tthis.totalValues = [];\r\n\r\n\t\tthis.x = this.parseX(data.columns);\r\n\r\n\t\tthis.totalStart = this.x[0];\r\n\r\n\t\tthis.totalEnd = this.x[this.x.length - 1];\r\n\r\n\t\tthis.parseData(data);\r\n\r\n\t}\r\n\r\n\tget activeLinesCount(){\r\n\r\n\t\tlet count = 0;\r\n\r\n\t\tfor (let lineIndex in this.lines){\r\n\t\t\tcount += this.lines[lineIndex].active ? 1 : 0;\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tparseX(columns) {\r\n\t\tfor (let column of columns){\r\n\t\t\tif (column[0] === 'x'){\r\n\t\t\t\tcolumn.shift();\r\n\t\t\t\treturn column;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tcreateLineCoords({id, name, color, coords}){\r\n\t\tthis.lines[`${id}`] = {\r\n\t\t\tname,\r\n\t\t\tcoords,\r\n\t\t\tcolor,\r\n\t\t\tactive: true\r\n\t\t}\r\n\t}\r\n\r\n\tgetCoordsFromColumns({key, columns}){\r\n\r\n\t\tfor(let column of columns){\r\n\r\n\t\t\tif (column[0] === key){\r\n\t\t\t\tcolumn.shift();\r\n\r\n\t\t\t\tthis.totalValues.push(...column);\r\n\r\n\t\t\t\treturn column;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined;\r\n\r\n\t}\r\n\r\n\tparseData(data){\r\n\r\n\t\tfor (let columnId in data.types){\r\n\t\t\tif (data.types[columnId] === 'line'){\r\n\t\t\t\tthis.createLineCoords({\r\n\t\t\t\t\tid: columnId,\r\n\t\t\t\t\tname: data.names[columnId],\r\n\t\t\t\t\tcolor: data.colors[columnId],\r\n\t\t\t\t\tcoords: this.getCoordsFromColumns({key: columnId, columns: data.columns})\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// remove all not unique values\r\n\t\tthis.totalValues = this.totalValues.filter((v, i, s) => s.indexOf(v) === i);\r\n\r\n\t\tthis.totalValues.sort((a, b) => {return a - b});\r\n\r\n\t}\r\n\r\n}\n\n//# sourceURL=webpack:///./src/js/ChartData.js?");

/***/ }),

/***/ "./src/js/ChartDrawier.js":
/*!********************************!*\
  !*** ./src/js/ChartDrawier.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ChartDrawier; });\nclass ChartDrawier {\r\n\r\n\tconstructor(){\r\n\r\n\t}\r\n\r\n\tcreateSVGItem(target, type, settings){\r\n\r\n\t\tconst item = document.createElementNS('http://www.w3.org/2000/svg', type);\r\n\r\n\t\tfor (const settingName in settings){\r\n\t\t\titem.setAttributeNS(null, settingName, settings[settingName]);\r\n\t\t}\r\n\r\n\t\ttarget.appendChild(item);\r\n\r\n\t\treturn item;\r\n\r\n\t}\r\n\r\n\tanimateItem(item, prop, startValue, endValue, miliseconds){\r\n\t\tconst step = endValue - startValue;\r\n\t\tthis.animate(function(timePassed) {\r\n\r\n\t\t\tif (item.classList.contains('active-item')){\r\n\r\n\t\t\t\tconst animationProgress = timePassed / miliseconds;\r\n\r\n\t\t\t\tconst value = (startValue + step * animationProgress);\r\n\r\n\t\t\t\titem.setAttribute(prop, parseFloat(Number(value).toFixed(9)));\r\n\r\n\t\t\t}\r\n\t\t}, miliseconds);\r\n\r\n\t}\r\n\r\n\tanimate(draw, duration) {\r\n\t\tvar start = performance.now();\r\n\t\trequestAnimationFrame(function animate(time) {\r\n\r\n\t\t\tvar timePassed = time - start;\r\n\r\n\t\t\tif (timePassed > duration) timePassed = duration;\r\n\r\n\t\t\tdraw(timePassed);\r\n\r\n\t\t\tif (timePassed < duration) {\r\n\r\n\t\t\t\trequestAnimationFrame(animate);\r\n\r\n\t\t\t}\r\n\r\n\t\t});\r\n\t}\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./src/js/ChartDrawier.js?");

/***/ }),

/***/ "./src/js/ChartTemplate.js":
/*!*********************************!*\
  !*** ./src/js/ChartTemplate.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ChartTemplate; });\n/* harmony import */ var _ChartDrawier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChartDrawier */ \"./src/js/ChartDrawier.js\");\n\r\n\r\nclass ChartTemplate {\r\n\r\n\tconstructor({appendTarget = body, settings}){\r\n\r\n\t\tthis.drawier = new _ChartDrawier__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n\r\n\t\tthis.layoutID = `chart-layout-${Math.floor(Math.random() * 100000)}`;\r\n\r\n\t\tthis.mainAppendTarget = document.querySelector(appendTarget);\r\n\r\n\t\tthis.layoutContorls = {};\r\n\r\n\t\tthis.settings = settings;\r\n\r\n\t\t// define chart elements (like wrapper, window, map, etc...)\r\n\t\tthis.elements = {};\r\n\r\n\t\tthis.cache = {};\r\n\r\n\t}\r\n\r\n\tget chartTemplate(){\r\n\t\treturn `\r\n\t\t\t<div class=\"chart\" id=\"${this.layoutID}\">\r\n\t\t\t\t<div class=\"chart__window\">\r\n\t\t\t\t\t<svg></svg>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div class=\"chart__map\">\r\n\t\t\t\t\t<svg></svg>\r\n\t\t\t\t</div>\r\n\t\t\t\t<div class=\"chart__buttons\"></div>\r\n\t\t\t</div>\r\n\t\t`;\r\n\t}\r\n\r\n\tget viewBoxWidth(){\r\n\t\treturn this.settings.viewBoxWidth;\r\n\t}\r\n\r\n\tget viewBoxHeight(){\r\n\t\treturn this.settings.viewBoxWidth / this.chartAspectRatio;\r\n\t}\r\n\r\n\tget chartSizeCoeff(){\r\n\t\treturn this.viewBoxWidth / this.elements.chartWrapper.clientWidth;\r\n\t}\r\n\r\n\tget currentColorScheme(){\r\n\t\tconst mode = this.settings.currentMode;\r\n\t\treturn this.settings[`${mode}Mode`];\r\n\t}\r\n\r\n\tget mapSliderWidth() {\r\n\t\treturn this.settings.mapSliderWidth;\r\n\t}\r\n\r\n\tget startChartValue(){\r\n\t\treturn this.layoutContorls.startChartSlider.x.baseVal.value;\r\n\t}\r\n\tset startChartValue(value){\r\n\t\tthis.layoutContorls.startChartSlider.x.baseVal.value = value;\r\n\t}\r\n\tget startChartWidth(){\r\n\t\treturn this.layoutContorls.startChartSlider.width.baseVal.value;\r\n\t}\r\n\r\n\tget endChartValue(){\r\n\t\treturn this.layoutContorls.endChartSlider.x.baseVal.value;\r\n\t}\r\n\tset endChartValue(value){\r\n\t\tthis.layoutContorls.endChartSlider.x.baseVal.value = value;\r\n\t}\r\n\tget endChartWidth(){\r\n\t\treturn this.layoutContorls.endChartSlider.width.baseVal.value;\r\n\t}\r\n\r\n\tget viewRangeWidth(){\r\n\t\treturn this.endChartValue - this.startChartValue;\r\n\t}\r\n\r\n\tget chartAspectRatio(){\r\n\t\treturn this.elements.chartWrapper.clientWidth / this.elements.chartWrapper.clientHeight;\r\n\t}\r\n\r\n\tget mapAspectRatio(){\r\n\t\treturn this.elements.mapWrapper.clientWidth / this.elements.mapWrapper.clientHeight;\r\n\t}\r\n\r\n\t// init all chart template\r\n\tinit(){\r\n\r\n\t\tthis.elements.layout = this.initLayout();\r\n\r\n\t\tthis.elements.chartWrapper = this.elements.layout.querySelector('.chart__window');\r\n\r\n\t\tthis.elements.mapWrapper = this.elements.layout.querySelector('.chart__map');\r\n\r\n\t\tthis.elements.buttonsWrapper = this.elements.layout.querySelector('.chart__buttons');\r\n\r\n\t\tthis.elements.chart = this.initChart();\r\n\r\n\t\tthis.elements.map = this.initMap();\r\n\r\n\t\tthis.setCurrentColorScheme();\r\n\r\n\t}\r\n\r\n\tinitLayout(){\r\n\r\n\t\tconst layout = document.createElement('div');\r\n\r\n\t\tlayout.classList.add('chart_wrapper');\r\n\r\n\t\tlayout.innerHTML = this.chartTemplate;\r\n\r\n\t\tthis.mainAppendTarget.append(layout);\r\n\r\n\t\treturn layout;\r\n\r\n\t}\r\n\r\n\tinitChart(){\r\n\r\n\t\tconst chart = this.elements.chartWrapper.querySelector('svg');\r\n\r\n\t\tchart.setAttribute('viewBox', `0 0 ${this.viewBoxWidth} ${this.viewBoxWidth / this.chartAspectRatio}`);\r\n\r\n\t\tthis.drawier.createSVGItem(chart, 'g', {class: 'value-lines-wrapper'});\r\n\t\tthis.drawier.createSVGItem(chart, 'g', {class: 'chart-wrapper'});\r\n\t\tthis.drawier.createSVGItem(chart, 'g', {class: 'tooltip-wrapper'});\r\n\t\tthis.drawier.createSVGItem(chart, 'g', {class: 'dates-wrapper'});\r\n\t\tthis.drawier.createSVGItem(chart, 'g', {class: 'values-wrapper'});\r\n\r\n\t\treturn chart;\r\n\r\n\t}\r\n\r\n\tinitMap(){\r\n\r\n\t\tconst map = this.elements.mapWrapper.querySelector('svg');\r\n\r\n\t\tmap.setAttribute('viewBox', `0 0 ${this.viewBoxWidth} ${this.viewBoxWidth / this.mapAspectRatio}`);\r\n\r\n\t\tthis.drawier.createSVGItem(map, 'g', {class: 'chart-wrapper'});\r\n\r\n\t\tthis.layoutContorls.viewRange = this.createMapViewRange(map);\r\n\r\n\t\t// init start slider\r\n\t\tthis.layoutContorls.startChartSlider = this.createSlider(map);\r\n\t\tthis.layoutContorls.startChartSlider.setAttributeNS(null, 'x', 0);\r\n\r\n\t\t// init start map background\r\n\t\tthis.layoutContorls.startMapBackground = this.createMapBackground(map);\r\n\t\tthis.layoutContorls.startMapBackground.setAttributeNS(null, 'x', 0);\r\n\r\n\t\t// init end slider\r\n\t\tthis.layoutContorls.endChartSlider = this.createSlider(map);\r\n\t\tthis.layoutContorls.endChartSlider.setAttributeNS(null, 'x', this.viewBoxWidth - this.endChartWidth);\r\n\r\n\t\t// init start map background\r\n\t\tthis.layoutContorls.endMapBackground = this.createMapBackground(map);\r\n\t\tthis.layoutContorls.endMapBackground.setAttributeNS(null, 'x', this.viewBoxWidth);\r\n\r\n\t\tthis.changeMapViewSize();\r\n\r\n\t\treturn map;\r\n\r\n\t}\r\n\r\n\tinitControlButtons(lines){\r\n\r\n\t\tconst buttons = [];\r\n\r\n\t\tfor (let lineID in lines){\r\n\r\n\t\t\tconst button = document.createElement('button');\r\n\r\n\t\t\tbutton.setAttribute('class', 'chart-control-button active');\r\n\r\n\t\t\tbutton.style.color = this.currentColorScheme.tooltipColor;\r\n\r\n\t\t\tbutton.style.borderColor = this.currentColorScheme.tooltipLineColor;\r\n\r\n\t\t\tbutton.innerHTML = `<span style=\"border-color:${lines[lineID].color}\"><div class=\"background\" style=\"background: ${lines[lineID].color}\"></div><i>âœ”</i></span> ${lines[lineID].name}`;\r\n\r\n\t\t\tbutton.dataset.lineid = lineID;\r\n\r\n\t\t\tthis.elements.buttonsWrapper.appendChild(button);\r\n\r\n\t\t\tbuttons.push(button);\r\n\r\n\t\t}\r\n\r\n\t\tthis.elements.buttons = buttons;\r\n\r\n\t}\r\n\r\n\tcreateLines({target, x, lines, start, end, min, max}){\r\n\r\n\t\tfor (let lineId in lines){\r\n\r\n\t\t\tlet pathLine = '';\r\n\r\n\t\t\tconst yCoords = lines[lineId].coords;\r\n\r\n\t\t\tfor (let coordIndex in x){\r\n\r\n\t\t\t\tcoordIndex = Number(coordIndex);\r\n\r\n\t\t\t\tconst xCoord = this.xValueToCoord(x[coordIndex], start, end);\r\n\t\t\t\tconst yCoord = this.yValueToCoord(yCoords[coordIndex], min, max, target);\r\n\r\n\t\t\t\tpathLine += (coordIndex === 0) ? `M${xCoord} ${yCoord}` : ` L ${xCoord} ${yCoord}`;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet path = target.querySelector(`.line-${lineId}`);\r\n\r\n\t\t\tif (path === null){\r\n\t\t\t\tconst settings = {\r\n\t\t\t\t\t'class': `line-${lineId}`,\r\n\t\t\t\t\t'stroke': lines[lineId].color,\r\n\t\t\t\t\t'stroke-width': this.chartSizeCoeff * this.settings.chartLineWidth,\r\n\t\t\t\t\t'fill': 'none'\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Create the chart path if it not exists\r\n\t\t\t\tpath = this.drawier.createSVGItem(target.querySelector('.chart-wrapper'), 'path', settings);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpath.setAttributeNS(null, 'd', pathLine);\r\n\t\t}\r\n\t}\r\n\r\n\tcreateDates({target, dates, start, end, totalStartDate, totalEndDate}){\r\n\r\n\t\tfor (const date of dates){\r\n\r\n\t\t\tlet x = this.xValueToCoord(date, start, end);\r\n\r\n\t\t\tlet text = target.querySelector(`.date-${date}`);\r\n\r\n\t\t\tif (text === null){\r\n\r\n\t\t\t\tconst settingsText = {\r\n\t\t\t\t\t'y': this.viewBoxHeight - this.viewBoxHeight * 0.05,\r\n\t\t\t\t\t'font-size': this.chartSizeCoeff * this.settings.fontSize,\r\n\t\t\t\t\t'class': `date-text date-${date} removing-item`,\r\n\t\t\t\t\t'color': this.currentColorScheme.textColor,\r\n\t\t\t\t\t'fill': this.currentColorScheme.textColor\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttext = this.drawier.createSVGItem(target.querySelector('.dates-wrapper'), 'text', settingsText);\r\n\r\n\t\t\t\tconst dateValue = new Date(date);\r\n\t\t\t\ttext.innerHTML = `${this.settings.monthNames[dateValue.getMonth()]} ${dateValue.getDate()}`;\r\n\t\t\t\ttext.setAttribute('y', this.viewBoxHeight);\r\n\r\n\t\t\t}\r\n\r\n\r\n\r\n\t\t\ttext.setAttribute('x', 0);\r\n\t\t\t\tif (date === totalStartDate){\r\n\t\t\t\t\tx += Math.ceil(text.clientWidth * 0.1);;\r\n\t\t\t\t}else if (date === totalEndDate){\r\n\t\t\t\t\tx -= Math.ceil(text.clientWidth * 1.1);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tx -= Math.floor(text.clientWidth / 2);\r\n\t\t\t\t}\r\n\t\t\ttext.setAttribute('x', x);\r\n\t\t\ttext.setAttributeNS(null, 'class', `date-${date} date-text active-item`);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcreateValues({target, steps, min, max}){\r\n\r\n\t\tfor (const value of steps){\r\n\r\n\t\t\tlet yOld;\r\n\r\n\t\t\tconst y = this.yValueToCoord(value, min, max, target);\r\n\r\n\t\t\tif (this.cache.oldMin !== undefined){\r\n\t\t\t\tyOld = this.yValueToCoord(value, this.cache.oldMin, this.cache.oldMax, target);\r\n\t\t\t}else{\r\n\t\t\t\tyOld = y;\r\n\t\t\t}\r\n\r\n\t\t\tlet text = target.querySelector(`.value-${value}-text`);\r\n\r\n\t\t\tlet path = target.querySelector(`.value-${value}-value`);\r\n\r\n\t\t\tif (path === null){\r\n\t\t\t\tconst settings = {\r\n\t\t\t\t\t'stroke': this.currentColorScheme.valueLineColor,\r\n\t\t\t\t\t'stroke-width': this.chartSizeCoeff * this.settings.valueLineWidth,\r\n\t\t\t\t\t'fill': 'none',\r\n\t\t\t\t\t'class': 'removing-item',\r\n\t\t\t\t\t'd': `M${0} ${yOld} L ${this.viewBoxWidth} ${yOld}`\r\n\t\t\t\t};\r\n\t\t\t\tpath = this.drawier.createSVGItem(target.querySelector('.value-lines-wrapper'), 'path', settings);\r\n\t\t\t}\r\n\r\n\t\t\tpath.setAttribute('class', `value-item active-item value-${value} value-${value}-value`);\r\n\t\t\tpath.setAttributeNS(null, 'd', `M${0} ${y} L ${this.viewBoxWidth} ${y}`);\r\n\r\n\t\t\tif (text === null){\r\n\t\t\t\tconst settings = {\r\n\t\t\t\t\t'x': 0,\r\n\t\t\t\t\t'font-size': this.chartSizeCoeff * this.settings.fontSize,\r\n\t\t\t\t\t'color': this.currentColorScheme.textColor,\r\n\t\t\t\t\t'fill': this.currentColorScheme.textColor,\r\n\t\t\t\t\t'class': 'removing-item',\r\n\t\t\t\t\t'y': yOld\r\n\t\t\t\t};\r\n\t\t\t\ttext = this.drawier.createSVGItem(target.querySelector('.values-wrapper'), 'text', settings);\r\n\t\t\t}\r\n\r\n\t\t\ttext.dataset.y = value;\r\n\r\n\t\t\tpath.dataset.y = value;\r\n\r\n\t\t\ttext.innerHTML = this.numberFormat(value);\r\n\r\n\t\t\ttext.setAttribute('class', `value-item active-item value-${value} value-${value}-text`);\r\n\r\n\t\t\tlet currentY = Number(text.getAttribute('y'));\r\n\r\n\t\t\tconst targetY = y - target.viewBox.baseVal.height * 0.01;\r\n\r\n\t\t\tif (currentY !== null){\r\n\t\t\t\tif (currentY !== targetY){\r\n\t\t\t\t\tlet time = 400;\r\n\t\t\t\t\tif (target.classList.contains('dragging')){\r\n\t\t\t\t\t\ttime = 100;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.drawier.animateItem(text, 'y', currentY, targetY, time);\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttext.setAttribute('y', targetY);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\ttext.setAttribute('y', targetY);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.cache.oldMin = min;\r\n\t\tthis.cache.oldMax = max;\r\n\t}\r\n\r\n\tcreateTooltip({x, values, clientY, start, end, min, max}){\r\n\r\n\t\tconst target = this.elements.chartWrapper;\r\n\r\n\t\tconst xCoord = this.xValueToCoord(x, start, end);\r\n\r\n\t\tlet tooltipPath = target.querySelector(`.tooltip-${x}`);\r\n\r\n\t\tlet tooltipHTML = ``;\r\n\r\n\t\tlet tooltipText = document.querySelector(`#tooltip-text-${x}`);\r\n\r\n\t\tif (tooltipPath === null){\r\n\r\n\t\t\tthis.removeItems('tooltip-item', `tooltip-${x}`);\r\n\r\n\t\t\tconst dateValue = new Date(x);\r\n\r\n\t\t\tconst settings = {\r\n\t\t\t\t'stroke': this.currentColorScheme.tooltipLineColor,\r\n\t\t\t\t'stroke-width': this.chartSizeCoeff * this.settings.tooltipLineWidth,\r\n\t\t\t\t'fill': 'none',\r\n\t\t\t\t'class': `tooltip-${x} tooltip-item`,\r\n\t\t\t\t'd': `M${xCoord} 0 L ${xCoord} ${this.viewBoxHeight}`,\r\n\t\t\t}\r\n\t\t\ttooltipPath = this.drawier.createSVGItem(target.querySelector('.tooltip-wrapper'), 'path', settings);\r\n\r\n\t\t\ttooltipHTML += `<span class=\"tooltip-date\">${this.settings.weekdaysNames[dateValue.getDay()]}, ${this.settings.monthNames[dateValue.getMonth()]} ${dateValue.getDate()}</span>`;\r\n\t\t\ttooltipHTML += `<div class=\"tooltip-values-wrapper\">`;\r\n\r\n\t\t\tfor (const chartValue of values){\r\n\r\n\t\t\t\tlet circleValue = target.querySelector(`.tooltip-value-${chartValue.y}`);\r\n\r\n\t\t\t\tconst yCoord = this.yValueToCoord(chartValue.y, min, max, target);\r\n\r\n\t\t\t\tif (circleValue === null){\r\n\r\n\t\t\t\t\tconst settings = {\r\n\t\t\t\t\t\t'stroke'      : chartValue.color,\r\n\t\t\t\t\t\t'stroke-width': this.chartSizeCoeff * this.settings.tooltipCircleLineWidth,\r\n\t\t\t\t\t\t'fill'        : this.currentColorScheme.background,\r\n\t\t\t\t\t\t'r'           : this.chartSizeCoeff * this.settings.tooltipCirclesRadius,\r\n\t\t\t\t\t\t'class'       : `tooltip-${x} tooltip-value-${chartValue.y} tooltip-item`\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcircleValue = this.drawier.createSVGItem(target.querySelector('.tooltip-wrapper'), 'circle', settings);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcircleValue.setAttributeNS(null, 'cx', xCoord);\r\n\t\t\t\tcircleValue.setAttributeNS(null, 'cy', yCoord);\r\n\r\n\r\n\t\t\t\ttooltipHTML += `<div class=\"tooltip-value-wrapper\" style=\"color: ${chartValue.color}\">\r\n\t\t\t\t\t<span class=\"tooltip-value\">${this.numberFormat([chartValue.y])}</span>\r\n\t\t\t\t\t<span class=\"tooltip-value-name\">${chartValue.name}</span>\r\n\t\t\t\t</div>`;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttooltipHTML += `</div>`;\r\n\r\n\r\n\r\n\t\t\tif (tooltipText === null){\r\n\t\t\t\ttooltipText = document.createElement('div');\r\n\t\t\t\ttooltipText.setAttribute('class', `tooltip-text tooltip-${x} tooltip-item`);\r\n\t\t\t\ttooltipText.setAttribute('id', `tooltip-text-${x}`);\r\n\t\t\t\tthis.elements.chartWrapper.appendChild(tooltipText);\r\n\t\t\t}\r\n\r\n\t\t\ttooltipText.innerHTML = tooltipHTML;\r\n\t\t\ttooltipText.style.background = this.currentColorScheme.tooltipBackground;\r\n\t\t\ttooltipText.style.color = this.currentColorScheme.tooltipColor;\r\n\r\n\t\t}\r\n\r\n\t\t// rect of chart\r\n\t\tconst bcrChart = this.elements.chart.getBoundingClientRect();\r\n\r\n\t\t// rect of tooltip (text)\r\n\t\tconst bcrTooltip = tooltipText.getBoundingClientRect();\r\n\r\n\t\t// rect of tooltip (line)\r\n\t\tconst bcrCurrentTooltipLine = tooltipPath.getBoundingClientRect();\r\n\r\n\t\t// get relative Y position of cursor\r\n\t\tconst chartY = clientY - bcrChart.top;\r\n\r\n\t\t// tooltip on top from cursor by offset\r\n\t\tlet left = ((bcrCurrentTooltipLine.left - bcrChart.left) - (bcrTooltip.width / 2));\r\n\t\tlet top = chartY - (bcrTooltip.height + this.settings.tooltipOffsetFromCursor);\r\n\r\n\t\t// tooltip on right from cursor by offset\r\n\t\tif (left < 0){\r\n\t\t\tleft = (bcrCurrentTooltipLine.left - bcrChart.left) + this.settings.tooltipOffsetFromCursor;\r\n\t\t\ttop = chartY - (bcrTooltip.height / 2);\r\n\r\n\t\t}\r\n\r\n\t\t// tooltip on left from cursor by offset\r\n\t\tif ((left + bcrTooltip.width) > bcrChart.width){\r\n\t\t\tleft = (bcrCurrentTooltipLine.left - bcrChart.left) - (bcrTooltip.width + this.settings.tooltipOffsetFromCursor);\r\n\t\t\ttop = chartY - (bcrTooltip.height / 2);\r\n\t\t}\r\n\r\n\t\t// tooltip on bottom from cursor by offset\r\n\t\tif (top < 0){\r\n\t\t\ttop = chartY + this.settings.tooltipOffsetFromCursor;\r\n\t\t}\r\n\r\n\r\n\t\t// tooltip on top (right/left) from cursor by offset\r\n\t\tif ((top + bcrTooltip.height) > (bcrChart.height - (bcrChart.height * (1 - this.settings.chartHeight)))){\r\n\t\t\ttop = chartY - (bcrTooltip.height + this.settings.tooltipOffsetFromCursor);\r\n\t\t}\r\n\r\n\r\n\t\ttooltipText.style.top = `${top}px`;\r\n\t\ttooltipText.style.left = `${left}px`;\r\n\t}\r\n\r\n\r\n\tcreateSlider(target){\r\n\r\n\t\tconst settings = {\r\n\t\t\t'y'     : 0,\r\n\t\t\t'width' : target.viewBox.baseVal.width * this.mapSliderWidth,\r\n\t\t\t'height': target.viewBox.baseVal.height,\r\n\t\t\t'fill'  : 'rgba(0,0,0,0)'\r\n\t\t};\r\n\r\n\t\tconst chartSlider = this.drawier.createSVGItem(target, 'rect', settings);\r\n\r\n\t\treturn chartSlider;\r\n\t}\r\n\r\n\tcreateMapBackground(target){\r\n\t\tconst settings = {\r\n\t\t\t'y'     : 0,\r\n\t\t\t'width' : 0,\r\n\t\t\t'height': target.viewBox.baseVal.height,\r\n\t\t\t'fill'  : this.currentColorScheme.mapNotVisibleBackground\r\n\t\t};\r\n\r\n\t\tconst mapBackground = this.drawier.createSVGItem(target, 'rect', settings);\r\n\r\n\t\treturn mapBackground;\r\n\t}\r\n\r\n\tcreateMapViewRange(target){\r\n\r\n\t\tconst settings = {\r\n\t\t\t'x'           : 0,\r\n\t\t\t'y'           : 0 - target.viewBox.baseVal.height * this.mapSliderWidth,\r\n\t\t\t'width'       : 0,\r\n\t\t\t'height'      : target.viewBox.baseVal.height + target.viewBox.baseVal.height * (this.mapSliderWidth * 2),\r\n\t\t\t'fill'        : 'rgba(0,0,0,0)',\r\n\t\t\t'stroke'      : this.currentColorScheme.startEndColor,\r\n\t\t\t'stroke-width': this.viewBoxWidth * this.mapSliderWidth\r\n\t\t};\r\n\r\n\t\tconst viewRange = this.drawier.createSVGItem(target, 'rect', settings);\r\n\r\n\t\treturn viewRange;\r\n\t}\r\n\r\n\tsetCurrentColorScheme(){\r\n\r\n\t\tthis.elements.layout.classList.add('scheme-change');\r\n\r\n\t\tdocument.querySelector('body').style.background = this.currentColorScheme.background;\r\n\r\n\t\tthis.elements.map.style.background = this.currentColorScheme.background;\r\n\r\n\t\tthis.elements.chart.style.background = this.currentColorScheme.background;\r\n\r\n\t\tthis.layoutContorls.viewRange.setAttributeNS(null, 'stroke', this.currentColorScheme.startEndColor);\r\n\r\n\t\tthis.layoutContorls.endMapBackground.setAttributeNS(null, 'fill', this.currentColorScheme.mapNotVisibleBackground);\r\n\r\n\t\tthis.layoutContorls.startMapBackground.setAttributeNS(null, 'fill', this.currentColorScheme.mapNotVisibleBackground);\r\n\r\n\t\tif (this.elements.buttons){\r\n\t\t\tfor (const button of this.elements.buttons){\r\n\t\t\t\tbutton.style.color = this.currentColorScheme.tooltipColor;\r\n\t\t\t\tbutton.style.borderColor = this.currentColorScheme.tooltipLineColor;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tconst texts = [...this.elements.layout.querySelector('.dates-wrapper').querySelectorAll('text'), ...this.elements.layout.querySelector('.values-wrapper').querySelectorAll('text')];\r\n\r\n\t\tfor (const text of texts){\r\n\t\t\ttext.setAttributeNS(null, 'color', this.currentColorScheme.textColor);\r\n\t\t\ttext.setAttributeNS(null, 'fill', this.currentColorScheme.textColor);\r\n\t\t}\r\n\r\n\t\tconst lines = this.elements.layout.querySelector('.value-lines-wrapper').querySelectorAll('path');\r\n\r\n\t\tfor (const line of lines){\r\n\t\t\tline.setAttributeNS(null, 'stroke', this.currentColorScheme.valueLineColor);\r\n\t\t}\r\n\r\n\t\tsetTimeout(() => this.elements.layout.classList.remove('scheme-change'), 0);\r\n\r\n\t}\r\n\r\n\tchangeStartPosition(value, minRangeWidth){\r\n\r\n\t\tconst maxOfStartPosition = this.endChartValue + this.endChartWidth - minRangeWidth;\r\n\r\n\t\tvalue = value > 0 ? value : 0;\r\n\r\n\t\tvalue = value < maxOfStartPosition ? value : maxOfStartPosition;\r\n\r\n\t\tthis.startChartValue = value;\r\n\r\n\t\tthis.layoutContorls.startMapBackground.setAttributeNS(null, 'width', this.startChartValue);\r\n\r\n\t\tthis.changeMapViewSize();\r\n\t}\r\n\r\n\r\n\r\n\tchangeEndPosition(value, minRangeWidth){\r\n\r\n\t\tconst minOfEndPosition = this.startChartValue + minRangeWidth - this.endChartWidth;\r\n\r\n\t\tvalue = value > minOfEndPosition ? value : minOfEndPosition;\r\n\r\n\t\tvalue = value + this.endChartWidth < this.viewBoxWidth ? value : this.viewBoxWidth - this.endChartWidth;\r\n\r\n\t\tthis.endChartValue = value;\r\n\r\n\t\tthis.layoutContorls.endMapBackground.setAttributeNS(null, 'width', this.viewBoxWidth - this.endChartValue + this.endChartWidth);\r\n\t\tthis.layoutContorls.endMapBackground.setAttributeNS(null, 'x', this.endChartValue + this.endChartWidth);\r\n\r\n\t\tthis.changeMapViewSize();\r\n\r\n\t}\r\n\r\n\r\n\tchangeMapViewSize(){\r\n\r\n\t\tconst left = this.startChartValue + (this.viewBoxWidth * (this.mapSliderWidth / 2));\r\n\r\n\t\tconst width = this.viewRangeWidth;\r\n\r\n\t\tthis.layoutContorls.viewRange.setAttributeNS(null, 'x', left);\r\n\t\tthis.layoutContorls.viewRange.setAttributeNS(null, 'width', width);\r\n\r\n\t}\r\n\r\n\r\n\taddNoDataPlaceholder(){\r\n\t\tlet placeholder = this.elements.layout.querySelector('.no-data-placeholder');\r\n\t\tif (placeholder === null){\r\n\t\t\tplaceholder = document.createElement('div');\r\n\t\t\tplaceholder.setAttribute('class', 'no-data-placeholder');\r\n\t\t\tplaceholder.innerHTML = '<h2>No data to display!</h2>';\r\n\t\t\tplaceholder.style.color = this.currentColorScheme.textColor;\r\n\t\t\tthis.elements.layout.querySelector('.chart__window').appendChild(placeholder);\r\n\t\t}\r\n\t}\r\n\r\n\tremoveItems(removingClass, drawingID = 'id-of-item-to-not-remove', action = 'remove', settings = {}){\r\n\r\n\t\tlet checkToNotRemove = [];\r\n\r\n\t\tif (typeof drawingID === 'string'){\r\n\t\t\tcheckToNotRemove.push(drawingID);\r\n\t\t}else if(Array.isArray(drawingID)){\r\n\t\t\tcheckToNotRemove = drawingID;\r\n\t\t}else{\r\n\t\t\treject('Wrong value of Drawing ID');\r\n\t\t}\r\n\r\n\t\tlet items = this.elements.layout.getElementsByClassName(removingClass);\r\n\r\n\t\tif (this.removeItem(items, checkToNotRemove, items.length, action, settings)){\r\n\t\t\treturn true;\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tremoveItem(items, checkToNotRemove, countToRemove, action, settings = {}){\r\n\t\tfor (const item of items){\r\n\t\t\tlet found = 0;\r\n\t\t\tfor (const checkID of checkToNotRemove){\r\n\t\t\t\tfound += item.classList.contains(checkID) ? 1 : 0;\r\n\t\t\t}\r\n\t\t\tif (found === 0){\r\n\t\t\t\tswitch (action){\r\n\t\t\t\t\tcase 'remove':\r\n\t\t\t\t\t\titem.remove();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'hide':\r\n\t\t\t\t\t\titem.classList.remove('active-item');\r\n\t\t\t\t\t\titem.classList.add('removing-item');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'hideByY':\r\n\t\t\t\t\t\tconst y = this.yValueToCoord(Number(item.dataset.y), settings.min, settings.max, this.elements.chart);\r\n\t\t\t\t\t\tconst yOld = this.yValueToCoord(Number(item.dataset.y), this.cache.oldMin, this.cache.oldMax, this.elements.chart);\r\n\r\n\t\t\t\t\t\tlet time = 400;\r\n\t\t\t\t\t\tif (this.elements.chart.classList.contains('dragging')){\r\n\t\t\t\t\t\t\ttime = 100;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.drawier.animateItem(item, 'y', yOld, y, time);\r\n\t\t\t\t\t\titem.classList.add('removing-item');\r\n\t\t\t\t\t\t// item.classList.remove('active-item');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcountToRemove--;\r\n\t\t\t}else{\r\n\t\t\t\tcountToRemove--;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (countToRemove !== 0){\r\n\t\t\treturn this.removeItem(items, checkToNotRemove, countToRemove, action, settings);\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tnumberFormat(value) {\r\n\t\tconst fixed = this.settings.decimalsInThousandRounding;\r\n\t\t// Nine Zeroes for Billions\r\n\t\treturn Math.abs(Number(value)) >= 1.0e+9\r\n\r\n\t\t? parseFloat(Number(Math.abs(Number(value)) / 1.0e+9).toFixed(fixed)) + \"B\"\r\n\t\t// Six Zeroes for Millions\r\n\t\t: Math.abs(Number(value)) >= 1.0e+6\r\n\r\n\t\t? parseFloat(Number(Math.abs(Number(value)) / 1.0e+6).toFixed(fixed)) + \"M\"\r\n\t\t// Three Zeroes for Thousands\r\n\t\t: Math.abs(Number(value)) >= 1.0e+3\r\n\r\n\t\t? parseFloat(Number(Math.abs(Number(value)) / 1.0e+3).toFixed(fixed)) + \"K\"\r\n\r\n\t\t: Math.abs(Number(value));\r\n\t}\r\n\r\n\txValueToCoord(x, start, end){\r\n\r\n\t\treturn (1 - ((end - x) / (end - start))) * this.viewBoxWidth;\r\n\r\n\t}\r\n\r\n\tyValueToCoord(y, min, max, target){\r\n\r\n\t\treturn (((max - min) - (y - min)) / (max - min)) * (this.viewBoxWidth * this.settings.chartHeight) / (target.clientWidth / target.clientHeight);\r\n\r\n\t}\r\n\r\n}\n\n//# sourceURL=webpack:///./src/js/ChartTemplate.js?");

/***/ }),

/***/ "./src/js/Resources.js":
/*!*****************************!*\
  !*** ./src/js/Resources.js ***!
  \*****************************/
/*! exports provided: getJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getJSON\", function() { return getJSON; });\nconst getJSON = function(url) {\r\n\r\n\treturn new Promise(function(resolve, reject){\r\n\r\n\t\tconst request = new XMLHttpRequest();\r\n\r\n\t\trequest.open('GET', url, true);\r\n\r\n\t\trequest.onload = function () {\r\n\r\n\t\t\tif (request.status >= 200 && request.status < 300) {\r\n\r\n\t\t\t\tresolve(JSON.parse(request.responseText));\r\n\r\n\t\t\t}else{\r\n\r\n\t\t\t\treject('Error: HTTP status - ' + request.status + ' on resource ' + url);\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trequest.send();\r\n\r\n\t});\r\n}\r\n\n\n//# sourceURL=webpack:///./src/js/Resources.js?");

/***/ }),

/***/ "./src/js/script.js":
/*!**************************!*\
  !*** ./src/js/script.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Chart */ \"./src/js/Chart.js\");\n/* harmony import */ var _Resources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Resources */ \"./src/js/Resources.js\");\n\r\n\r\n\r\n\r\nconst charts = [];\r\n\r\nconst switchLink = document.createElement('a');\r\n\r\nswitchLink.setAttribute('class', 'switch-link');\r\n\r\nswitchLink.dataset.currentmode = 'day';\r\n\r\nswitchLink.innerHTML = `Switch to night mode`;\r\n\r\nswitchLink.addEventListener('click', (event) => {\r\n\r\n\tconst button = event.target;\r\n\r\n\tconst currentMode = button.dataset.currentmode;\r\n\r\n\tconst switchTo = button.dataset.currentmode === 'day' ? 'night' : 'day';\r\n\r\n\tif (charts.length > 0){\r\n\t\tfor (const chart of charts){\r\n\t\t\tchart.changeSetting('currentMode', switchTo);\r\n\t\t}\r\n\t\tbutton.dataset.currentmode = switchTo;\r\n\t\tbutton.innerHTML = `Switch to ${currentMode} mode`;\r\n\t\tbutton.style.color = switchTo === 'night' ? '#fff' : '#333';\r\n\t}\r\n});\r\n\r\ndocument.querySelector('body').appendChild(switchLink);\r\n\r\nObject(_Resources__WEBPACK_IMPORTED_MODULE_1__[\"getJSON\"])('data/chart_data.json').then((data) => {\r\n\tfor (const dataOfChart of data){\r\n\t\tcharts.push(new _Chart__WEBPACK_IMPORTED_MODULE_0__[\"default\"](dataOfChart));\r\n\t}\r\n});\n\n//# sourceURL=webpack:///./src/js/script.js?");

/***/ }),

/***/ "./src/scss/style.scss":
/*!*****************************!*\
  !*** ./src/scss/style.scss ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/scss/style.scss?");

/***/ }),

/***/ 0:
/*!******************************************************!*\
  !*** multi ./src/js/script.js ./src/scss/style.scss ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/js/script.js */\"./src/js/script.js\");\nmodule.exports = __webpack_require__(/*! ./src/scss/style.scss */\"./src/scss/style.scss\");\n\n\n//# sourceURL=webpack:///multi_./src/js/script.js_./src/scss/style.scss?");

/***/ })

/******/ });